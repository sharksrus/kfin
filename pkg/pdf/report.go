package pdf

import (
	"fmt"
	"sort"
	"time"

	"github.com/jung-kurt/gofpdf"
)

type ReportData struct {
	PodCosts         []PodCost
	TotalCost        float64
	HardwareCost     float64
	ElecCost         float64
	ControlPlaneCost float64
	Nodes            []NodeInfo
	GeneratedAt      time.Time
	ContextName      string
	ClusterName      string
}

type PodCost struct {
	Name      string
	Namespace string
	CPU       string
	Memory    string
	Cost      float64
}

type NodeInfo struct {
	Name         string
	MemoryGB     float64
	HardwareCost float64
	ElecCost     float64
	TotalCost    float64
}

type namespaceSummary struct {
	Name string
	Pods int
	Cost float64
}

func Generate(data ReportData, filename string) error {
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.SetMargins(12, 12, 12)
	pdf.SetAutoPageBreak(true, 12)
	pdf.SetTitle("kfin Cost Report", false)
	pdf.SetAuthor("kfin", false)
	pdf.SetCreator("kfin", false)
	pdf.SetFooterFunc(func() {
		pdf.SetY(-10)
		pdf.SetFont("Arial", "I", 8)
		pdf.SetTextColor(110, 110, 110)
		pdf.CellFormat(0, 5, fmt.Sprintf("Generated by kfin  |  Page %d", pdf.PageNo()), "", 0, "C", false, 0, "")
	})

	nonZeroPods := filterAndSortPods(data.PodCosts)
	nsSummary := summarizeNamespaces(nonZeroPods)

	pdf.AddPage()
	drawReportHeader(pdf, data)
	drawSummaryCards(pdf, data, len(nonZeroPods), len(nsSummary))

	rows := make([][]string, 0, len(data.Nodes)+1)
	var nodeTotal float64
	for _, n := range data.Nodes {
		rows = append(rows, []string{
			truncateWithDots(n.Name, 26),
			fmt.Sprintf("%.1f GB", n.MemoryGB),
			money(n.HardwareCost),
			money(n.ElecCost),
			money(n.TotalCost),
		})
		nodeTotal += n.TotalCost
	}
	rows = append(rows, []string{"TOTAL", "", "", "", money(nodeTotal)})
	drawTable(
		pdf,
		"Node Costs (Monthly)",
		[]string{"NODE", "MEMORY", "HARDWARE", "ELECTRICITY", "TOTAL"},
		[]float64{52, 26, 28, 32, 28},
		[]string{"L", "R", "R", "R", "R"},
		rows,
	)

	nsRows := make([][]string, 0, len(nsSummary))
	for _, ns := range nsSummary {
		nsRows = append(nsRows, []string{
			truncateWithDots(ns.Name, 35),
			fmt.Sprintf("%d", ns.Pods),
			money(ns.Cost),
		})
	}
	if len(nsRows) == 0 {
		nsRows = append(nsRows, []string{"No non-zero namespace costs", "-", "-"})
	}
	drawTable(
		pdf,
		"Namespace Rollup (Non-Zero)",
		[]string{"NAMESPACE", "PODS", "MONTHLY COST"},
		[]float64{96, 24, 46},
		[]string{"L", "R", "R"},
		nsRows,
	)

	podRows := make([][]string, 0, len(nonZeroPods)+1)
	var podTotal float64
	for _, p := range nonZeroPods {
		podRows = append(podRows, []string{
			truncateWithDots(p.Name, 30),
			truncateWithDots(p.Namespace, 18),
			p.CPU,
			p.Memory,
			money(p.Cost),
		})
		podTotal += p.Cost
	}
	if len(podRows) == 0 {
		podRows = append(podRows, []string{"No non-zero pod costs", "-", "-", "-", "-"})
	} else {
		podRows = append(podRows, []string{"TOTAL", "", "", "", money(podTotal)})
	}
	drawTable(
		pdf,
		"Pod Costs (Non-Zero, Highest First)",
		[]string{"POD", "NAMESPACE", "CPU REQ", "MEM REQ", "MONTHLY COST"},
		[]float64{58, 38, 24, 28, 18 + 24},
		[]string{"L", "L", "R", "R", "R"},
		podRows,
	)

	return pdf.OutputFileAndClose(filename)
}

func drawReportHeader(pdf *gofpdf.Fpdf, data ReportData) {
	pdf.SetFillColor(18, 28, 31)
	pdf.SetDrawColor(18, 28, 31)
	pdf.Rect(12, 12, 186, 24, "FD")

	pdf.SetTextColor(0, 194, 146)
	pdf.SetFont("Arial", "B", 22)
	pdf.SetXY(16, 16)
	pdf.CellFormat(120, 8, "kFIN Cost Report", "", 0, "L", false, 0, "")

	pdf.SetTextColor(228, 232, 235)
	pdf.SetFont("Arial", "", 10)
	pdf.SetXY(16, 25)
	pdf.CellFormat(120, 6, "Kubernetes cluster monthly cost breakdown", "", 0, "L", false, 0, "")
	pdf.SetFont("Arial", "", 9)
	pdf.SetXY(16, 30)
	pdf.CellFormat(120, 5, fmt.Sprintf("Context: %s  |  Cluster: %s", data.ContextName, data.ClusterName), "", 0, "L", false, 0, "")

	pdf.SetFont("Arial", "", 9)
	pdf.SetXY(146, 16)
	pdf.CellFormat(48, 6, "Generated", "", 0, "R", false, 0, "")
	pdf.SetFont("Arial", "B", 10)
	pdf.SetXY(146, 22)
	pdf.CellFormat(48, 6, data.GeneratedAt.Format("2006-01-02 15:04 MST"), "", 0, "R", false, 0, "")
	pdf.Ln(30)
}

func drawSummaryCards(pdf *gofpdf.Fpdf, data ReportData, nonZeroPods int, namespaces int) {
	const x = 12.0
	const y = 40.0
	const w = 186.0
	const h = 22.0
	pdf.SetDrawColor(208, 215, 222)
	pdf.SetFillColor(247, 250, 252)
	pdf.Rect(x, y, w, h, "FD")

	pdf.SetXY(x+4, y+4)
	pdf.SetTextColor(52, 58, 64)
	pdf.SetFont("Arial", "", 9)
	pdf.CellFormat(36, 5, "TOTAL MONTHLY", "", 0, "L", false, 0, "")
	pdf.CellFormat(34, 5, "HARDWARE", "", 0, "L", false, 0, "")
	pdf.CellFormat(34, 5, "ELECTRICITY", "", 0, "L", false, 0, "")
	pdf.CellFormat(34, 5, "CONTROL PLANE", "", 0, "L", false, 0, "")
	pdf.CellFormat(34, 5, "PODS / NS", "", 0, "L", false, 0, "")

	pdf.SetXY(x+4, y+10)
	pdf.SetTextColor(16, 24, 32)
	pdf.SetFont("Arial", "B", 12)
	pdf.CellFormat(36, 7, money(data.TotalCost), "", 0, "L", false, 0, "")
	pdf.CellFormat(34, 7, money(data.HardwareCost), "", 0, "L", false, 0, "")
	pdf.CellFormat(34, 7, money(data.ElecCost), "", 0, "L", false, 0, "")
	pdf.CellFormat(34, 7, money(data.ControlPlaneCost), "", 0, "L", false, 0, "")
	pdf.CellFormat(34, 7, fmt.Sprintf("%d / %d", nonZeroPods, namespaces), "", 0, "L", false, 0, "")

	pdf.SetY(y + h + 4)
}

func drawTable(pdf *gofpdf.Fpdf, title string, headers []string, widths []float64, aligns []string, rows [][]string) {
	ensurePageSpace(pdf, 24)

	pdf.SetTextColor(15, 21, 28)
	pdf.SetFont("Arial", "B", 13)
	pdf.CellFormat(0, 8, title, "", 1, "L", false, 0, "")
	pdf.SetDrawColor(213, 220, 227)
	pdf.Line(12, pdf.GetY(), 198, pdf.GetY())
	pdf.Ln(2)

	drawHeader := func() {
		pdf.SetFont("Arial", "B", 9)
		pdf.SetTextColor(245, 248, 250)
		pdf.SetFillColor(30, 64, 72)
		for i, h := range headers {
			pdf.CellFormat(widths[i], 7, h, "1", 0, "C", true, 0, "")
		}
		pdf.Ln(-1)
	}

	drawHeader()
	pdf.SetFont("Arial", "", 9)
	pdf.SetTextColor(18, 26, 34)
	pdf.SetDrawColor(223, 228, 233)
	alt := false

	for _, row := range rows {
		ensurePageSpace(pdf, 9)
		if pdf.GetY() < 26 {
			drawHeader()
		}
		if alt {
			pdf.SetFillColor(249, 251, 252)
		} else {
			pdf.SetFillColor(255, 255, 255)
		}

		for i := range headers {
			val := ""
			if i < len(row) {
				val = row[i]
			}
			align := "L"
			if i < len(aligns) {
				align = aligns[i]
			}
			pdf.CellFormat(widths[i], 6.5, val, "1", 0, align, true, 0, "")
		}
		pdf.Ln(-1)
		alt = !alt
	}
	pdf.Ln(5)
}

func ensurePageSpace(pdf *gofpdf.Fpdf, needed float64) {
	_, pageH := pdf.GetPageSize()
	if pdf.GetY()+needed > pageH-12 {
		pdf.AddPage()
	}
}

func filterAndSortPods(pods []PodCost) []PodCost {
	filtered := make([]PodCost, 0, len(pods))
	for _, p := range pods {
		if p.Cost > 0 {
			filtered = append(filtered, p)
		}
	}
	sort.Slice(filtered, func(i, j int) bool {
		if filtered[i].Cost == filtered[j].Cost {
			if filtered[i].Namespace == filtered[j].Namespace {
				return filtered[i].Name < filtered[j].Name
			}
			return filtered[i].Namespace < filtered[j].Namespace
		}
		return filtered[i].Cost > filtered[j].Cost
	})
	return filtered
}

func summarizeNamespaces(pods []PodCost) []namespaceSummary {
	byNS := make(map[string]*namespaceSummary)
	for _, p := range pods {
		item, ok := byNS[p.Namespace]
		if !ok {
			item = &namespaceSummary{Name: p.Namespace}
			byNS[p.Namespace] = item
		}
		item.Pods++
		item.Cost += p.Cost
	}
	out := make([]namespaceSummary, 0, len(byNS))
	for _, s := range byNS {
		out = append(out, *s)
	}
	sort.Slice(out, func(i, j int) bool {
		if out[i].Cost == out[j].Cost {
			return out[i].Name < out[j].Name
		}
		return out[i].Cost > out[j].Cost
	})
	return out
}

func money(v float64) string {
	return fmt.Sprintf("$%.2f", v)
}

func truncateWithDots(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	if maxLen <= 3 {
		return s[:maxLen]
	}
	return s[:maxLen-3] + "..."
}
